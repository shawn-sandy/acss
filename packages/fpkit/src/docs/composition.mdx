import { Meta } from '@storybook/blocks';

<Meta title="Guides/Composition" />

# Component Composition Guide

Learn how to build custom components by composing existing @fpkit/acss primitives.

> **üìñ Full Guide:** For comprehensive documentation, see [docs/guides/composition.md](https://github.com/shawn-sandy/acss/blob/main/packages/fpkit/docs/guides/composition.md)

---

## Why Composition?

**Composition over duplication** ensures:

- ‚úÖ **Consistency** - Reusing components ensures UI consistency
- ‚úÖ **Maintainability** - Bug fixes propagate automatically
- ‚úÖ **Reduced Code** - Less code to write and maintain
- ‚úÖ **Tested Components** - Leverage existing test coverage
- ‚úÖ **Accessibility** - Inherit WCAG-compliant patterns

---

## Decision Tree

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ New Component Need: "ComponentName" ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Does fpkit have a    ‚îÇ  YES ‚Üí Use fpkit component
    ‚îÇ component that meets ‚îÇ        Customize with CSS variables
    ‚îÇ the need exactly?    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ NO
           ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Can it be built by   ‚îÇ  YES ‚Üí Compose existing components
    ‚îÇ combining 2+ fpkit   ‚îÇ        Import and combine
    ‚îÇ components?          ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ NO
           ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Can I extend an      ‚îÇ  YES ‚Üí Wrap fpkit component
    ‚îÇ fpkit component with ‚îÇ        Add custom logic/styling
    ‚îÇ additional features? ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ NO
           ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Create custom        ‚îÇ
    ‚îÇ component from       ‚îÇ
    ‚îÇ scratch using fpkit  ‚îÇ
    ‚îÇ styling patterns     ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Common Patterns

### Pattern 1: Container + Content

Wrap fpkit components with additional structure:

```tsx
import { Button, Badge } from '@fpkit/acss'

export const StatusButton = ({ status, children, ...props }) => {
  return (
    <Button {...props}>
      {children}
      <Badge variant={status}>{status}</Badge>
    </Button>
  )
}

// Usage
<StatusButton status="active">Server Status</StatusButton>
```

---

### Pattern 2: Conditional Composition

Different combinations based on props:

```tsx
import { Alert, Dialog } from '@fpkit/acss'

export const Notification = ({ inline, variant, children, ...props }) => {
  if (inline) {
    return <Alert variant={variant}>{children}</Alert>
  }

  return (
    <Dialog {...props}>
      <Alert variant={variant}>{children}</Alert>
    </Dialog>
  )
}

// Usage
<Notification inline variant="success">Saved!</Notification>
<Notification isOpen={showModal} variant="error">Error!</Notification>
```

---

### Pattern 3: Enhanced Wrapper

Add behavior around fpkit components:

```tsx
import { Button } from '@fpkit/acss'
import { useState } from 'react'

export const LoadingButton = ({ loading, onClick, children, ...props }) => {
  const [isLoading, setIsLoading] = useState(loading)

  const handleClick = async (e) => {
    setIsLoading(true)
    try {
      await onClick?.(e)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <Button
      {...props}
      disabled={isLoading || props.disabled}
      onClick={handleClick}
    >
      {isLoading ? 'Loading...' : children}
    </Button>
  )
}

// Usage
<LoadingButton onClick={async () => await saveData()}>
  Save
</LoadingButton>
```

---

### Pattern 4: List of Components

Render multiple instances:

```tsx
import { Tag } from '@fpkit/acss'

export const TagList = ({ tags, onRemove, ...props }) => {
  return (
    <div className="tag-list" {...props}>
      {tags.map((tag) => (
        <Tag
          key={tag.id}
          onClose={onRemove ? () => onRemove(tag) : undefined}
        >
          {tag.label}
        </Tag>
      ))}
    </div>
  )
}

// Usage
<TagList
  tags={[
    { id: 1, label: 'React' },
    { id: 2, label: 'TypeScript' },
  ]}
  onRemove={handleRemoveTag}
/>
```

---

### Pattern 5: Compound Component

Multiple related components working together:

```tsx
import { Card, Button } from '@fpkit/acss'

export const ActionCard = ({ title, children, actions, ...props }) => {
  return (
    <Card {...props}>
      <Card.Header>
        <Card.Title>{title}</Card.Title>
      </Card.Header>
      <Card.Content>{children}</Card.Content>
      {actions && (
        <Card.Footer>
          {actions.map((action, i) => (
            <Button key={i} {...action} />
          ))}
        </Card.Footer>
      )}
    </Card>
  )
}

// Usage
<ActionCard
  title="Confirm Action"
  actions={[
    { children: 'Cancel', variant: 'secondary', onClick: handleCancel },
    { children: 'Confirm', variant: 'primary', onClick: handleConfirm },
  ]}
>
  Are you sure you want to proceed?
</ActionCard>
```

---

## Real-World Examples

### Example 1: Icon Button

```tsx
import { Button } from '@fpkit/acss'

export const IconButton = ({ icon, children, iconPosition = 'left', ...props }) => {
  return (
    <Button {...props}>
      {iconPosition === 'left' && <span className="icon">{icon}</span>}
      {children}
      {iconPosition === 'right' && <span className="icon">{icon}</span>}
    </Button>
  )
}

// Usage
<IconButton icon="üíæ" variant="primary">
  Save Changes
</IconButton>
```

---

### Example 2: Confirm Button

```tsx
import { Button, Dialog } from '@fpkit/acss'
import { useState } from 'react'

export const ConfirmButton = ({
  confirmTitle = 'Confirm Action',
  confirmMessage = 'Are you sure?',
  onConfirm,
  children,
  ...props
}) => {
  const [showConfirm, setShowConfirm] = useState(false)

  const handleConfirm = () => {
    setShowConfirm(false)
    onConfirm?.()
  }

  return (
    <>
      <Button {...props} onClick={() => setShowConfirm(true)}>
        {children}
      </Button>

      <Dialog isOpen={showConfirm} onClose={() => setShowConfirm(false)}>
        <h2>{confirmTitle}</h2>
        <p>{confirmMessage}</p>
        <div className="dialog-actions">
          <Button variant="secondary" onClick={() => setShowConfirm(false)}>
            Cancel
          </Button>
          <Button variant="primary" onClick={handleConfirm}>
            Confirm
          </Button>
        </div>
      </Dialog>
    </>
  )
}

// Usage
<ConfirmButton
  variant="danger"
  confirmTitle="Delete Account"
  confirmMessage="This action cannot be undone."
  onConfirm={handleDeleteAccount}
>
  Delete Account
</ConfirmButton>
```

---

### Example 3: Tag Input

```tsx
import { Tag } from '@fpkit/acss'
import { useState } from 'react'

export const TagInput = ({ value = [], onChange, placeholder, ...props }) => {
  const [inputValue, setInputValue] = useState('')

  const addTag = () => {
    if (inputValue.trim() && !value.includes(inputValue.trim())) {
      onChange?.([...value, inputValue.trim()])
      setInputValue('')
    }
  }

  const removeTag = (tagToRemove) => {
    onChange?.(value.filter((tag) => tag !== tagToRemove))
  }

  return (
    <div className="tag-input" {...props}>
      <div className="tag-list">
        {value.map((tag) => (
          <Tag key={tag} onClose={() => removeTag(tag)}>
            {tag}
          </Tag>
        ))}
      </div>
      <input
        type="text"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onKeyDown={(e) => {
          if (e.key === 'Enter') {
            e.preventDefault()
            addTag()
          }
        }}
        placeholder={placeholder || 'Add tag...'}
      />
    </div>
  )
}

// Usage
<TagInput
  value={tags}
  onChange={setTags}
  placeholder="Add technology..."
/>
```

---

## Anti-Patterns to Avoid

### ‚ùå Over-Composition

Too many nested layers:

```tsx
// ‚ùå Bad
<OuterWrapper>
  <MiddleContainer>
    <InnerBox>
      <ContentWrapper>
        <Button>Click</Button>
      </ContentWrapper>
    </InnerBox>
  </MiddleContainer>
</OuterWrapper>

// ‚úÖ Good
<Container>
  <Button>Click</Button>
</Container>
```

**Rule:** Keep composition depth ‚â§ 3 levels.

---

### ‚ùå Prop Drilling

Passing props through multiple layers:

```tsx
// ‚ùå Bad
<Wrapper theme={theme} size={size}>
  <Container theme={theme} size={size}>
    <Button theme={theme} size={size} />
  </Container>
</Wrapper>

// ‚úÖ Good
const ThemeContext = createContext()

<ThemeProvider value={{ theme, size }}>
  <Wrapper>
    <Container>
      <Button />
    </Container>
  </Wrapper>
</ThemeProvider>
```

**Rule:** If passing >3 props through >2 levels, use context.

---

### ‚ùå Duplicating Instead of Composing

```tsx
// ‚ùå Bad
export const Status = ({ variant, children }) => {
  return <span className={`status status-${variant}`}>{children}</span>
}

// ‚úÖ Good
import { Badge } from '@fpkit/acss'
export const Status = Badge
```

**Rule:** If code looks similar to fpkit, reuse it.

---

### ‚ùå Composing Incompatible Components

```tsx
// ‚ùå Bad - nested interactive elements (a11y violation)
<Link href="/page">
  <Button>Click me</Button>
</Link>

// ‚úÖ Good - use polymorphic 'as' prop
<Button as="a" href="/page">
  Click me
</Button>
```

**Rule:** Check component APIs for `as` prop support.

---

## Styling Composed Components

Customize with CSS variables:

```tsx
import { Button, Badge } from '@fpkit/acss'

export const PriorityButton = ({ priority, children, ...props }) => {
  return (
    <Button
      {...props}
      style={{
        '--btn-padding-inline': '2rem',
        '--btn-gap': '0.75rem',
      }}
    >
      {children}
      <Badge
        variant={priority === 'high' ? 'error' : 'default'}
        style={{
          '--badge-fs': '0.75rem',
        }}
      >
        {priority}
      </Badge>
    </Button>
  )
}
```

---

## TypeScript Support

Extend fpkit types:

```tsx
import { Button, type ButtonProps } from '@fpkit/acss'

interface LoadingButtonProps extends ButtonProps {
  loading?: boolean
  loadingText?: string
}

export const LoadingButton = ({
  loading,
  loadingText = 'Loading...',
  children,
  ...props
}: LoadingButtonProps) => {
  return (
    <Button {...props} disabled={loading || props.disabled}>
      {loading ? loadingText : children}
    </Button>
  )
}
```

---

## Best Practices

### ‚úÖ Do

- Start with fpkit components
- Preserve accessibility
- Use CSS variables for customization
- Document which fpkit components you're using
- Test integration
- Export cleanly

### ‚ùå Don't

- Don't duplicate fpkit logic
- Don't break accessibility (nested interactive elements)
- Don't over-compose (‚â§3 levels)
- Don't prop drill (use context)
- Don't ignore polymorphism (`as` prop)

---

## Additional Resources

- **üìñ [Full Composition Guide](https://github.com/shawn-sandy/acss/blob/main/packages/fpkit/docs/guides/composition.md)** - Comprehensive patterns and examples
- **üé® [CSS Variables Guide](https://github.com/shawn-sandy/acss/blob/main/packages/fpkit/docs/guides/css-variables.md)** - Styling composed components
- **‚ôø [Accessibility Guide](https://github.com/shawn-sandy/acss/blob/main/packages/fpkit/docs/guides/accessibility.md)** - Maintaining accessibility
- **üß™ [Testing Guide](https://github.com/shawn-sandy/acss/blob/main/packages/fpkit/docs/guides/testing.md)** - Testing compositions

---

**Remember:** Compose when it creates clearer, more maintainable code that leverages tested, accessible primitives from @fpkit/acss.
